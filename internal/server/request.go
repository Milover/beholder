package server

import (
	"errors"
	"fmt"

	pb "github.com/Milover/beholder/internal/server/proto"
	"github.com/google/uuid"
	"google.golang.org/protobuf/proto"
)

var (
	ErrProcessReq = errors.New("could not process request") // Request processing error
)

// Internal use errors.
var (
	errSanity = errors.New("sanity check failed")

	errUUIDVersion = errors.New("UUID version != 7")

	errMsgHeader = errors.New("bad message header")
	errMsgType   = errors.New("bad message type")

	errMsgOp     = errors.New("bad op message")
	errOpHeader  = errors.New("bad op header")
	errOpCode    = errors.New("bad op code")
	errOpMsgType = errors.New("bad op message type")
	errOpPayload = errors.New("bad op payload")
)

// A request is a container which relates a [proto.Message] request to
// the originating connection.
//
// Since all protobuf message types implement [proto.Message] through
// pointer receivers, request can be (shallowly) copied.
type request struct {
	orig *connection   // request message origin
	msg  proto.Message // request message
}

// processRequest processes a request message.
// It returns a request response, the response's UUIDv7 and any errors
// which occured.
//
// processRequest always returns a valid response and UUID, even if there is
// an error.
//
// WARNING: the response message is generated by modifying the request message,
// which might not be the best idea.
func (s *AcquisitionServer) processRequest(req request) (*pb.MessageWrapper, string, error) {
	var resp *pb.MessageWrapper
	var opcode pb.OpCode
	defer func() {
		s.Logf("processed request (uuid: %v; conn: %p; opcode: %v)",
			resp.Header.Uuid, req.orig, opcode)
	}()
	// check request
	op, service, uuid, err := verifyRequest(req.msg)
	if err != nil {
		resp, opcode = defaultResponse(uuid)
		return resp, uuid, fmt.Errorf("%w: %w", ErrProcessReq, err)
	}
	// execute service
	respPayload, err := service(op, s)
	if err != nil {
		respPayload = &pb.Error{
			Code:        pb.ErrorCode_ERROR_CODE_FAIL,
			Description: ErrMsg.Error(),
		}
	}
	// construct service response
	var errResp error
	if resp, opcode, errResp = makeResponse(req.msg, respPayload); errResp != nil {
		resp, opcode = defaultResponse(uuid)
		err = errors.Join(err, errResp)
	}
	return resp, uuid, err
}

// defaultResponse creates a new default request response with the provided UUID.
//
// The default response message is an op-message with a 'bad-message' error
// payload.
func defaultResponse(uuid string) (*pb.MessageWrapper, pb.OpCode) {
	return &pb.MessageWrapper{
		Header: &pb.MessageHeader{
			Uuid: uuid,
			Type: pb.MessageType_MESSAGE_TYPE_OP,
		},
		Payload: &pb.MessageWrapper_Op{
			Op: &pb.Op{
				Header: &pb.OpHeader{
					Code: pb.OpCode_OP_CODE_UNKNOWN,
					Type: pb.OpMessageType_OP_MESSAGE_TYPE_RESPONSE,
				},
				Payload: &pb.Op_Error{
					Error: &pb.Error{
						Code:        pb.ErrorCode_ERROR_CODE_FAIL,
						Description: ErrMsg.Error(),
					},
				},
			},
		},
	}, pb.OpCode_OP_CODE_UNKNOWN
}

// verifyRequest extracts an op-message from req and returns the associated
// service, UUIDv7, either req's UUID or a new one, and any errors which occur.
//
// verifyRequest always returns a valid UUID, even if there is an error,
// however, the op-message and the service will be nil ho
func verifyRequest(req proto.Message) (*pb.Op, Service, string, error) {
	// check header
	r, ok := req.(*pb.MessageWrapper)
	if !ok || r.Header == nil {
		return nil, nil, uuid.Must(uuid.NewV7()).String(), ErrMsg
	}
	// check UUID
	uuid, err := verifyRequestUUID(r.Header.Uuid)
	if err != nil {
		return nil, nil, uuid, err
	}
	// check request type
	if r.Header.Type != pb.MessageType_MESSAGE_TYPE_OP {
		return nil, nil, uuid, errMsgType
	}
	// verify request payload
	op, err := verifyRequestPayload(r)
	if err != nil {
		return nil, nil, uuid, err
	}
	// lookup service
	service, found := services[op.Header.Code]
	if !found {
		return nil, nil, uuid, errOpCode
	}
	return op, service, uuid, nil
}

// verifyRequestUUID verifies that s is a valid UUIDv7.
// verifyRequestUUID always returns a valid UUID, even if there is an error.
func verifyRequestUUID(s string) (string, error) {
	uid, err := uuid.Parse(s)
	if err != nil {
		return uuid.Must(uuid.NewV7()).String(), err
	}
	if uid.Version() != 7 {
		return uuid.Must(uuid.NewV7()).String(), errUUIDVersion
	}
	return s, nil
}

// verifyRequestPayload extract an op-message from req.
// If there is an error, the op-message will be nil.
func verifyRequestPayload(req proto.Message) (*pb.Op, error) {
	r, ok := req.(*pb.MessageWrapper)
	if !ok {
		return nil, fmt.Errorf("server.verifyReqPayload: %w: r == nil", errSanity)
	}
	op, ok := (r.Payload).(*pb.MessageWrapper_Op)
	if !ok {
		return nil, fmt.Errorf("server.verifyReqPayload: %w: op == nil", errSanity)
	}
	switch {
	case op == nil, op.Op == nil:
		return nil, errMsgOp
	case op.Op.Header == nil:
		return nil, errOpHeader
	case op.Op.Header.Type != pb.OpMessageType_OP_MESSAGE_TYPE_REQUEST:
		return nil, errOpMsgType
	}
	return op.Op, nil
}

// makeResponse creates a request response by swapping req's payload with
// the one provided.
// If there is an error, a nil response and an OP_CODE_UNKNOWN op-code are
// returned.
func makeResponse(req proto.Message, payload proto.Message) (*pb.MessageWrapper, pb.OpCode, error) {
	opcode := pb.OpCode_OP_CODE_UNKNOWN
	r, ok := req.(*pb.MessageWrapper)
	if !ok {
		return nil, opcode, fmt.Errorf("server.makeResponse: %w: r == nil", errSanity)
	}
	op, ok := (r.Payload).(*pb.MessageWrapper_Op)
	if !ok {
		return nil, opcode, fmt.Errorf("server.makeResponse: %w: op == nil", errSanity)
	}
	if op.Op == nil {
		return nil, opcode, fmt.Errorf("server.makeResponse: %w: op.Op == nil", errSanity)
	}
	op.Op.Header.Type = pb.OpMessageType_OP_MESSAGE_TYPE_RESPONSE
	switch p := payload.(type) {
	case *pb.Error:
		op.Op.Payload = &pb.Op_Error{Error: p}
	default:
		return nil, opcode, fmt.Errorf("server.makeResponse: %w: payload.(type)", errSanity)
	}
	return r, op.Op.Header.Code, nil
}
