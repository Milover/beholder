package server

import (
	"errors"
	"fmt"

	pb "github.com/Milover/beholder/internal/server/proto"
	"github.com/google/uuid"
	"google.golang.org/protobuf/proto"
)

var (
	ErrProcessReq = errors.New("could not process request") // Request processing error
)

// Internal use errors.
var (
	errSanity = errors.New("sanity check failed")

	errUUIDVersion = errors.New("UUID version != 7")

	errMsgHeader = errors.New("bad message header")
	errMsgType   = errors.New("bad message type")

	errMsgOp     = errors.New("bad op message")
	errOpHeader  = errors.New("bad op header")
	errOpCode    = errors.New("bad op code")
	errOpMsgType = errors.New("bad op message type")
	errOpPayload = errors.New("bad op payload")
)

// processRequest processes a request message.
// It returns a request response, the response's UUIDv7 and any errors
// which occured.
//
// processRequest always returns a valid response and UUID, even if there is
// an error.
//
// WARNING: the response message is generated by modifying the request message,
// which might not be the best idea.
func (s *AcquisitionServer) processRequest(req proto.Message) (*pb.MessageWrapper, string, error) {
	// check request
	op, service, uuid, err := verifyRequest(req)
	if err != nil {
		resp := defaultResponse(uuid)
		return resp, uuid, fmt.Errorf("%w: %w", ErrProcessReq, err)
	}
	// execute service
	respPayload, err := service(op, s)
	if err != nil {
		respPayload = &pb.Error{Code: pb.ErrorCode_ERROR_CODE_FAIL, Description: ErrMsg.Error()}
	}
	// construct service response
	var resp *pb.MessageWrapper
	var errResp error
	if resp, errResp = makeResponse(req, respPayload); errResp != nil {
		resp = defaultResponse(uuid)
		err = errors.Join(err, errResp)
	}
	return resp, uuid, err
}

// defaultResponse creates a new default request response with the provided UUID.
//
// The default response message is an 'error-failed' message of unknown type.
func defaultResponse(uuid string) *pb.MessageWrapper {
	return &pb.MessageWrapper{
		Header: &pb.MessageHeader{Uuid: uuid, Type: pb.MessageType_MESSAGE_TYPE_ERROR},
		Payload: &pb.MessageWrapper_Error{
			Error: &pb.Error{Code: pb.ErrorCode_ERROR_CODE_FAIL, Description: ErrMsg.Error()},
		},
	}
}

// verifyRequest extracts an op-message from req and returns the associated
// service, UUIDv7, either req's UUID or a new one, and any errors which occur.
//
// verifyRequest always returns a valid UUID, even if there is an error,
// however, the op-message and the service will be nil ho
func verifyRequest(req proto.Message) (*pb.Op, Service, string, error) {
	// check header
	r, ok := req.(*pb.MessageWrapper)
	if !ok || r.Header == nil {
		return nil, nil, uuid.Must(uuid.NewV7()).String(), ErrMsg
	}
	// check UUID
	uuid, err := verifyRequestUUID(r.Header.Uuid)
	if err != nil {
		return nil, nil, uuid, err
	}
	// check request type
	if r.Header.Type != pb.MessageType_MESSAGE_TYPE_OP {
		return nil, nil, uuid, errMsgType
	}
	// verify request payload
	op, err := verifyRequestPayload(r)
	if err != nil {
		return nil, nil, uuid, err
	}
	// lookup service
	service, found := services[op.Header.Code]
	if !found {
		return nil, nil, uuid, errOpCode
	}
	return op, service, uuid, nil
}

// verifyRequestUUID verifies that s is a valid UUIDv7.
// verifyRequestUUID always returns a valid UUID, even if there is an error.
func verifyRequestUUID(s string) (string, error) {
	uid, err := uuid.Parse(s)
	if err != nil {
		return uuid.Must(uuid.NewV7()).String(), err
	}
	if uid.Version() != 7 {
		return uuid.Must(uuid.NewV7()).String(), errUUIDVersion
	}
	return s, nil
}

// verifyRequestPayload extract an op-message from req.
// If there is an error, the op-message will be nil.
func verifyRequestPayload(req proto.Message) (*pb.Op, error) {
	r, ok := req.(*pb.MessageWrapper)
	if !ok {
		return nil, fmt.Errorf("server.verifyReqPayload: %w: r == nil", errSanity)
	}
	op, ok := (r.Payload).(*pb.MessageWrapper_Op)
	if !ok {
		return nil, fmt.Errorf("server.verifyReqPayload: %w: op == nil", errSanity)
	}
	switch {
	case op == nil, op.Op == nil:
		return nil, errMsgOp
	case op.Op.Header == nil:
		return nil, errOpHeader
	case op.Op.Header.Type != pb.OpMessageType_OP_MESSAGE_TYPE_REQUEST:
		return nil, errOpMsgType
	}
	return op.Op, nil
}

// makeResponse creates a request response by swapping req's payload with
// the one provided.
// If there is an error, the response will be nil.
func makeResponse(req proto.Message, payload proto.Message) (*pb.MessageWrapper, error) {
	r, ok := req.(*pb.MessageWrapper)
	if !ok {
		return nil, fmt.Errorf("server.makeResponse: %w: r == nil", errSanity)
	}
	op, ok := (r.Payload).(*pb.MessageWrapper_Op)
	if !ok {
		return nil, fmt.Errorf("server.makeResponse: %w: op == nil", errSanity)
	}
	if op.Op == nil {
		return nil, fmt.Errorf("server.makeResponse: %w: op.Op == nil", errSanity)
	}

	op.Op.Header.Type = pb.OpMessageType_OP_MESSAGE_TYPE_RESPONSE
	switch p := payload.(type) {
	case *pb.Error:
		op.Op.Payload = &pb.Op_Error{Error: p}
	default:
		return nil, fmt.Errorf("server.makeResponse: %w: payload.(type)", errSanity)
	}
	return r, nil
}
